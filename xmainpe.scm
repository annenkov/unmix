#lang racket
(require racket/mpair)
(require "xpe.scm"
         "xggg.scm"
         "x-misc.scm")

(define (umainpe:generate-residual-program o-file ann-prog goalsvv)
  (define o-port #f)
  (define pending #f)
  (define names #f)
  (define counts #f)
  (define (generate-residual-program-pe)
    (let ((s-prog (caddr ann-prog))
          (d-prog (cadr ann-prog))
          (rf (car ann-prog)))
      (let ((%%120 ($specialize-fundef ann-prog '())))
        (let ((fname %%120))
          (let ((%%121 `(,fname unquote goalsvv)))
            (let ((conf (pairs->mpairs %%121))) ; converting to mutable
              (set! counts '())
              (set! pending '())
              (set! names '())
              (find-name! conf)
              (choose-conf-pe)))))))
  (define (choose-conf-pe)
    (if (null? pending)
      '()
      (let ((rest (cdr pending)) (conf (car pending)))
        (set! pending rest)
        (let ((%%122 ($specialize-fundef ann-prog (mpairs->pairs conf))))
          (let ([body (pairs->mpairs (cadr %%122))] ; converting to mutable
                [dvn (car %%122)])
            (update! body)
            (let* ((fname (cdr (assoc conf names)))
                   (fundef `(,fname ,dvn = ,body)))
              (print-fundef (map mpairs->pairs fundef)) ; converting back to regular pairs
              (choose-conf-pe)))))))
  (define (generate-residual-program-gn)
    (let ((%%123 ($specialize-fundef-$1 '())))
      (let ((fname %%123))
        (let ((%%124 `(,fname unquote goalsvv)))
          (let ((conf %%124))
            (set! counts '())
            (set! pending '())
            (set! names '())
            (find-name! conf)
            (choose-conf-gn))))))
  (define (choose-conf-gn)
    (if (null? pending)
      '()
      (let ((rest (cdr pending)) (conf (car pending)))
        (set! pending rest)
        (let ((%%125 ($specialize-fundef-$1 conf)))
          (let ([body (pairs->mpairs (cadr %%125))] ; converting to mutable
                [dvn (car %%125)])
            (update! body)
            (let* ((fname (cdr (assoc conf names)))
                   (fundef `(,fname ,dvn = ,body)))
              (print-fundef (map mpairs->pairs fundef)) ; converting back to regular pairs
              (choose-conf-gn)))))))
  (define (print-fundef fundef)
    (display "*")
    (pretty-write fundef o-port)
    (newline o-port)
    (newline o-port))
  (define (update! exp)
    (cond ((symbol? exp) #f)
          ((equal? (mcar exp) 'quote) (let ((const (mcadr exp))) #f))
          ((equal? (mcar exp) 'call)
           (let ((exp* (mcddr exp)) (conf (mcadr exp)))
             (mfor-each update! exp*)
             (set-mcar! (mcdr exp) (find-name! conf))))
          ((equal? (mcar exp) 'xcall)
           (let ((exp* (mcddr exp)) (fname (mcadr exp)))
             (mfor-each update! exp*)))
          (else
           (let ((exp* (mcdr exp)) (op (mcar exp))) (mfor-each update! exp*)))))
  (define (find-name! conf)
    (let ((%%126 (assoc conf names)))
      (let ((conf-descr %%126) (fname (mcar conf)))
        (when (not conf-descr)
          (begin
            (set! conf-descr `(,conf unquote (make-fname! fname)))            
            (set! names `(,conf-descr unquote names))
            (set! pending `(,conf unquote pending))))
        (cdr conf-descr))))
  (define (make-fname! fname)
    (string->symbol
      (string-append
        (symbol->string fname)
        "-$"
        (number->string (get-free-count! fname)))))
  (define (get-free-count! fname)
    (let ((fname-descr (massq fname counts)))
      (if fname-descr
        (let ((count (+ 1 (mcdr fname-descr))))
          (set-mcdr! fname-descr count)
          count)
        (begin (set! counts (pairs->mpairs `((,fname . 1) unquote counts))) 1)))) ; converting to mutable
  (set! o-port (open-output-file o-file))
  (if (null? ann-prog)
    (generate-residual-program-gn)
    (generate-residual-program-pe))
  (close-output-port o-port))

(provide (all-defined-out))