#lang racket
(require racket/mpair)
(require "x-misc.rkt"
         "xresfn.rkt")

(define (upcd:prevent-call-duplication! prog)
  (define (pcd-loop! prog)
    (display "Abstract Call Interpretation... Iterations: ")
    (let ((descr (abstract-call-interpretation prog)))
      (newline)
      (let ((program-modified? (make-rcall-prog! prog descr)))
        (if program-modified?
          (begin
            (display "Some \"call(s)\" has (have) been replaced with \"rcall(s)\"")
            (newline)
            (pcd-loop! prog))
          (begin
            (display "There is no call duplication risk")
            (newline)
            prog)))))
  (define (abstract-call-interpretation prog)
    (define descr #f)
    (define descr-modified? #f)
    (define (collect-c-args-prog!)
      (mfor-each
        (lambda (fundef)
          (let ((body (mcar (mcddddr fundef)))
                (dvn (mcaddr fundef))
                (svn (mcadr fundef))
                (fname (mcar fundef)))
            (let ((%%100 (massq fname descr)))
              (let ((dvv (mcadr %%100))) (collect-c-args! body dvn dvv)))))
        prog))
    (define (collect-c-args! exp vn vv)
      (cond ((symbol? exp) #f)
            ((equal? (mcar exp) 'static) #f)
            ((equal? (mcar exp) 'ifs)
             (let ((exp* (mcddr exp))) (collect-c-args*! exp* vn vv)))
            ((equal? (mcar exp) 'ifd)
             (let ((exp* (mcdr exp))) (collect-c-args*! exp* vn vv)))
            ((equal? (mcar exp) 'call)
             (let ((d-exp* (mcadddr exp))
                   (s-exp* (mcaddr exp))
                   (fname (mcadr exp)))
               (let ((descr (collect-c-args*! d-exp* vn vv))
                     (arg* (c-eval* d-exp* vn vv descr)))
                 (update-c-args! fname arg*))))
            ((equal? (mcar exp) 'rcall)
             (let ((d-exp* (mcadddr exp))
                   (s-exp* (mcaddr exp))
                   (fname (mcadr exp)))
               (collect-c-args*! d-exp* vn vv)))
            ((equal? (mcar exp) 'xcall)
             (let ((exp* (mcddr exp)) (fname (mcadr exp)))
               (collect-c-args*! exp* vn vv)))
            (else
             (let ((exp* (mcdr exp)) (op (mcar exp)))
               (collect-c-args*! exp* vn vv)))))
    (define (collect-c-args*! exp* vn vv)
      (mfor-each (lambda (exp) (collect-c-args! exp vn vv)) exp*))
    (define (collect-c-results-prog!)
      (mmap (lambda (fundef)
             (let ((body (mcar (mcddddr fundef)))
                   (dvn (mcaddr fundef))
                   (svn (mcadr fundef))
                   (fname (mcar fundef)))
               (let ((%%101 (massq fname descr)))
                 (let ((dvv (mcadr %%101)))
                   (let ((%%102 (c-eval body dvn dvv descr)))
                     (let ((res %%102)) (update-c-result! fname res)))))))
           prog))
    (define (initial-c-descr)
      (mmap (lambda (fundef)
             (let ((dvn (mcaddr fundef))
                   (svn (mcadr fundef))
                   (fname (mcar fundef)))
               (pairs->mpairs `(,fname ,(mmap (lambda (par) 'e) dvn) . e))))
           prog))
    (define (update-c-args! fname args)
      (let ((%%103 (massq fname descr)))
        (let ((fdescr (mcdr %%103)))
          (let ((res1 (mcdr fdescr)) (args1 (mcar fdescr)))
            (let ((%%104 (lub* args args1)))
              (let ((lub-args %%104))
                (when (not (equal? lub-args args1))
                  (begin
                    (set-mcar! fdescr lub-args)
                    (set! descr-modified? #t)))))))))
    (define (update-c-result! fname res)
      (let ((%%105 (massq fname descr)))
        (let ((fdescr (mcdr %%105)))
          (let ((res1 (mcdr fdescr)) (args1 (mcar fdescr)))
            (let ((%%106 (lub res res1)))
              (let ((lub-res %%106))
                (when (not (equal? lub-res res1))
                  (begin
                    (set-mcdr! fdescr lub-res)
                    (set! descr-modified? #t)))))))))
    (set! descr (initial-c-descr))
    (let recalc-c-descr ()
      (display "*")
      (set! descr-modified? #f)
      (collect-c-args-prog!)
      (collect-c-results-prog!)
      (if descr-modified? (recalc-c-descr) descr)))
  (define (c-eval exp vn vv descr)
    (cond ((symbol? exp) (lookup-variable exp vn vv))
          ((equal? (mcar exp) 'static) 'e)
          ((equal? (mcar exp) 'ifs)
           (let ((exp* (mcddr exp))) (lub-list (c-eval* exp* vn vv descr))))
          ((equal? (mcar exp) 'ifd)
           (let ((exp* (mcdr exp))) (lub-list (c-eval* exp* vn vv descr))))
          ((equal? (mcar exp) 'call)
           (let ((d-exp* (mcadddr exp)) (s-exp* (mcaddr exp)) (fname (mcadr exp)))
             (let ((%%107 (massq fname descr)))
               (let ((res (mcddr %%107)))
                 (lub res (lub-list (c-eval* d-exp* vn vv descr)))))))
          ((equal? (mcar exp) 'rcall)
           (let ((d-exp* (mcadddr exp)) (s-exp* (mcaddr exp)) (fname (mcadr exp)))
             'c))
          ((equal? (mcar exp) 'xcall)
           (let ((exp* (mcddr exp)) (fname (mcadr exp)))
             (lub-list (c-eval* exp* vn vv descr))))
          (else
           (let ((exp* (mcdr exp)) (op (mcar exp)))
             (lub-list (c-eval* exp* vn vv descr))))))
  (define (c-eval* exp* vn vv descr)
    (mmap (lambda (exp) (c-eval exp vn vv descr)) exp*))
  (define (lookup-variable vname vn vv)
    (if (and (null? vn) (null? vv))
      (error "Undefined variable: " vname)
      (let ((vrest (mcdr vv)) (vv (mcar vv)) (nrest (mcdr vn)) (vn (mcar vn)))
        (if (eq? vname vn) vv (lookup-variable vname nrest vrest)))))
  (define (lub ind1 ind2) (if (eq? ind1 'c) 'c ind2))
  (define (lub* ind1* ind2*) (mmap lub ind1* ind2*))
  (define (lub-list ind*) (if (mmemq 'c ind*) 'c 'e))
  (define (make-rcall-prog! prog descr)
    (define dupl #f)
    (define program-modified? #f)
    (define (make-rcall-func*!)
      (mfor-each (lambda (fundef) (make-rcall-func! fundef)) prog))
    (define (make-rcall-func! fundef)
      (let ((body (mcar (mcddddr fundef)))
            (dvn (mcaddr fundef))
            (svn (mcadr fundef))
            (fname (mcar fundef)))
        (let ((%%108 (massq fname descr)))
          (let ((dvv (mcadr %%108))) (make-rcall! body dvn dvv)))))
    (define (make-rcall! exp vn vv)
      (cond ((symbol? exp) '())
            ((equal? (mcar exp) 'static) '())
            ((equal? (mcar exp) 'ifs)
             (let ((exp* (mcddr exp))) (make-rcall*! exp* vn vv)))
            ((equal? (mcar exp) 'ifd)
             (let ((exp* (mcdr exp))) (make-rcall*! exp* vn vv)))
            ((equal? (mcar exp) 'call)
             (let ((d-exp* (mcadddr exp))
                   (s-exp* (mcaddr exp))
                   (fname (mcadr exp)))
               (make-rcall*! d-exp* vn vv)
               (let ((d-arg* (c-eval* d-exp* vn vv descr)))
                 (when (dangerous-parameter? fname d-arg*)
                   (begin
                     (set-mcar! exp 'rcall)
                     (set! program-modified? #t))))))
            ((equal? (mcar exp) 'rcall)
             (let ((d-exp* (mcadddr exp))
                   (s-exp* (mcaddr exp))
                   (fname (mcadr exp)))
               (make-rcall*! d-exp* vn vv)))
            ((equal? (mcar exp) 'xcall)
             (let ((exp* (mcddr exp)) (fname (mcadr exp)))
               (make-rcall*! exp* vn vv)))
            (else
             (let ((exp* (mcdr exp)) (op (mcar exp)))
               (make-rcall*! exp* vn vv)))))
    (define (make-rcall*! exp* vn vv)
      (mfor-each (lambda (exp) (make-rcall! exp vn vv)) exp*))
    (define (dangerous-parameter? fname arg*)
      (and (mmemq 'c arg*)
           (let ((%%109 (massq fname dupl)))
             (let ((dupl* (mcdr %%109))) (dangerous-par? arg* dupl*)))))
    (define (dangerous-par? arg* dupl*)
      (if (and (null? arg*) (null? dupl*))
        #f
        (let ((dupl*-rest (mcdr dupl*))
              (dupl (mcar dupl*))
              (arg*-rest (mcdr arg*))
              (arg (mcar arg*)))
          (or (and (eq? arg 'c) dupl) (dangerous-par? arg*-rest dupl*-rest)))))
    (set! dupl (make-dupl-descr-prog prog))
    (set! program-modified? #f)
    (make-rcall-func*!)
    program-modified?)
  (define (make-dupl-descr-prog prog)
    (mmap (lambda (fundef)
           (let ((body (mcar (mcddddr fundef)))
                 (dvn (mcaddr fundef))
                 (svn (mcadr fundef))
                 (fname (mcar fundef)))
             (pairs->mpairs `(,fname  ; converting to mutable
               unquote
               (mmap (lambda (vname) (> (max-occurrences vname body) 1)) dvn)))))
         prog))
  (define (max-occurrences vname exp)
    (cond ((symbol? exp) (if (eq? vname exp) 1 0))
          ((equal? (mcar exp) 'static) 0)
          ((equal? (mcar exp) 'ifs)
           (let ((exp3 (mcadddr exp)) (exp2 (mcaddr exp)) (exp1 (mcadr exp)))
             (max (max-occurrences vname exp2) (max-occurrences vname exp3))))
          ((equal? (mcar exp) 'ifd)
           (let ((exp3 (mcadddr exp)) (exp2 (mcaddr exp)) (exp1 (mcadr exp)))
             (let ((n1 (max-occurrences vname exp1))
                   (n2 (max-occurrences vname exp2))
                   (n3 (max-occurrences vname exp3)))
               (max (+ n1 n2) (+ n1 n3)))))
          ((equal? (mcar exp) 'call)
           (let ((d-exp* (mcadddr exp))) (max-occurrences* vname d-exp*)))
          ((equal? (mcar exp) 'rcall)
           (let ((d-exp* (mcadddr exp))) (max-occurrences* vname d-exp*)))
          ((equal? (mcar exp) 'xcall)
           (let ((exp* (mcddr exp))) (max-occurrences* vname exp*)))
          (else (let ((exp* (mcdr exp))) (max-occurrences* vname exp*)))))
  (define (max-occurrences* vname exp*)
    (mfoldl-map + 0 (lambda (exp) (max-occurrences vname exp)) exp*))
  (display "Preventing Call Duplication")
  (newline)
  (let ((s-fundef* (caddr prog)) (d-fundef* (cadr prog)) (rf (car prog)))
    (pcd-loop! d-fundef*)
    (let ((rf (uresfn:collect-residual-functions d-fundef*)))
      (display "-- Done --")
      (newline)
      `(,rf ,d-fundef* ,s-fundef*))))


(provide (all-defined-out))