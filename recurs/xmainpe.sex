;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                 ;;
;;  File:     xmainpe.s                                            ;;
;;  Project:  the specializer Unmix                                ;;
;;  Author:   S.A.Romanenko, the Institute for Applied             ;;
;;            Mathematics, the USSR Acedemy of Sciences,           ;;
;;            Moscow.                                              ;;
;;  Created:  5 May 1989                                           ;;
;;  Revised:  8 April 1990                                         ;;
;;            August 1990                                          ;;
;;            December 1992                                        ;;
;;            October 1993  (R.Glueck)                             ;;
;;                                                                 ;;
;;  Contents: The standard part of the Partial Evaluator           ;;
;;            as well as of the residual program generators        ;;
;;            produced by specializing the Partial Evaluator.      ;;
;;                                                                 ;;
;;  Note:     Depth-first specialization.                          ;;
;;                                                                 ;;
;;            Requires no macros and can be used for stand-alone   ;;
;;            program generators produced by Unmix.                ;;
;;                                                                 ;;
;; This part is not to be specialized because the parameters of    ;;
;; the functions are dynamic.                                      ;;
;;                                                                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;  Data structures used by the partial evaluator:
;;  =============================================
;;
;;  Configuration:
;;
;;    <Configuration>     ::= ( <Fname> > . <Sv> )
;;    <Sv>                ::= ( <Lisp S-expression>* )
;;
;;      A configuration is a possible runtime function call,
;;    which causes the partial evaluator to produce a specialized
;;    version of the function <Fname> with respect to the values
;;    <Sv> of the static parameters.
;;
;;  NameList:
;;
;;    <NameList>  ::= ()
;;                |   (( <Configuration> . <NewName> ) . <NameList> )
;;
;;    In <NameList> each <Configuration> is associated with
;;  a <NewFname> used to denote the residual function obtained by
;;  specializing <Fname> with respect to <Sv>.
;;
;;  CountList:
;;
;;    <CountList>  ::= ()
;;                 |   (( <Fname> . <Int> ) . <CountList> )
;;
;;    In <CountList> each <Fname> of associated with an integer,
;;  which is equal to the number of residual functions produced
;;  from the function <Fname>.


;;  Naming conventions:
;;  ==================
;;
;;    ann-prog    - the annotated Mixwell program
;;    conf        - a configuration
;;    fundef      - the annotated function definition
;;    sn          - a list of static variable names
;;    dn          - a list of dynamic variable names
;;    sv          - a list of static variable values
;;    dv          - a list of dynamic variable values


(define umainpe:o-port '())  ;; An output port to which the residual program
                             ;; is to be written.

(define umainpe:names '())   ;; A mapping from configurations to residual
                             ;; function names.

(define umainpe:counts '())  ;; A mapping from source function names
                             ;; to counts of residual functions produced.

;;
;; This function is the entry point.
;; If "ann-prog" is empty, it means that the residual program
;; is to be generated by a residual program generator (which
;; is supposed to be created and loaded in advance).
;; Otherwise, the residual program will be generated by
;; ordinary partial evaluation.
;;

(define (umainpe:generate-residual-program o-file ann-prog goalsv)

  (set! umainpe:o-port (open-output-file o-file))
;  (set-line-length! 78 umainpe:o-port)             ; PCScheme
  (set! umainpe:counts  '())
  (set! umainpe:names   '())

  (if (null? ann-prog)
      ($start goalsv)
      ($specialize-fundef ann-prog goalsv))

  (set! umainpe:counts  '())
  (set! umainpe:names   '())
  (close-output-port umainpe:o-port))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                 ;;
;;       Updating NameList and CountList                           ;;
;;                                                                 ;;
;;    All configurations that have not been recorded in "names"    ;;
;; are given a new name name and inserted in "names" and           ;;
;; the name count in "counts" is updated.                          ;;
;;                                                                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; Returns the residual function name corresponding
;; to the configuration fname and sv. Updates "umainpe:names"
;; and "umainpe:counts", if necessary.
;;

(define (umainpe:find-name! fname sv)

  ;;
  ;; Returns a pair (bool . rfname)  where rfname is a residual function
  ;; name, and bool is true if the rfname is new (which means that no
  ;; specialized version of the function exists), #false otherwise.
  ;;

  (define (make-fname! fname)
    (string->symbol
     (string-append
      (symbol->string fname)
      "-$"
      (number->string (get-free-count! fname)))   ; PCScheme '(int) as 2nd arg
     ))

  ;;
  ;; Returns the number of residual functions produced
  ;; from the source function "fname" and increases
  ;; the counter.
  ;;

  (define (get-free-count! fname)
    (let ((fname-descr (assq fname umainpe:counts)))
      (if fname-descr
        (let ((count (+ 1 (cdr fname-descr))))
          (set-cdr! fname-descr count)
          count)
        (begin
          (set! umainpe:counts `((,fname . 1) . ,umainpe:counts))
          1)
        )))

;  (display (list '-- fname '--)) (newline)  ; tracing residualized calls
;  (display sv) (newline)                    ; tracing static values

  (let* (( conf  `(,fname . ,sv) )
         ( conf-descr  (assoc conf umainpe:names) )
         ( bool  (not conf-descr) )
         )
      (if bool
          (begin
            (set! conf-descr     `(,conf . ,(make-fname! fname)))
            (set! umainpe:names  `(,conf-descr . ,umainpe:names))
            (display "<")
            ))
      `(,bool . ,(cdr conf-descr))
      ))

;;
;; Prints a residual function definition.
;; Returns the name of the function as result.
;;

(define (umainpe:print-fundef! fname var body)
  (display ">")
  (write `(,fname ,var = ,body) umainpe:o-port)
  (newline umainpe:o-port)
  (newline umainpe:o-port)
  fname)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                 ;;
;;          Applying functions with given symbolic name            ;;
;;                                                                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; "XAPPLY" is called from the file "xpe.s".
;;
;; The call
;;      (XAPPLY 'fname (list exp1 exp2 ... expN))
;; is equivalent to
;;      (fname exp1 exp2 ... expn).
;;
;;

(define xapply
  (let ((proc-list '()))
    (lambda (fname args)
      (let ((fname/proc (assq fname proc-list)))
        (if fname/proc
            (apply (cdr fname/proc) args)
            (let ((proc (eval fname)))
              (set! proc-list `((,fname . ,proc) . ,proc-list))
              (apply proc args)
              ))))))
